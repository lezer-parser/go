@precedence {
  unary
  mult @left
  add @left
  compare @left
  and @left
  or @left
  send @left

  pointer
  convert
  dot
  index
  slice
  type
  call
  channelIn
  channelOut

  else @right
}

@top SourceFile {
  (PackageClause semi)?
  (ImportDecl semi)*
  semiSep<declaration | FunctionDecl | MethodDecl>
}

@skip { space | LineComment | BlockComment }

PackageName { identifier ~identifier }

TypeName[@dynamicPrecedence=-1] { identifier ~identifier }

typeName { QualifiedType { (PackageName ".")+ TypeName } | TypeName }

VariableName { identifier ~identifier }

QualifiedName { (PackageName ".")+ VariableName }

LabelName { identifier }

FieldName { identifier ~identifier }

ParameterizedType { typeName TypeArgs }

TypeArgs { "[" commaSep1<type> "]" }

TypeParams[@dynamicPrecedence=-1] { "[" TypeParam "]" }

TypeParam { typeName ("," typeName)* typeElem }

type[@isGroup=Type] {
  PointerType { "*" !pointer type } |
  FunctionType { kw<"func"> signature } |
  InterfaceType { kw<"interface"> InterfaceBody { "{" ((MethodElem | typeElem) semi)* "}" } } |
  ChannelType {
    kw<"chan"> type |
    kw<"chan"> "<-" type !channelIn |
    "<-" kw<"chan"> type !channelOut
  } |
  ParenthesizedType { ~paren "(" type ~paren ")" } |
  literalType
}

literalType {
  StructType { kw<"struct"> StructBody { "{" (FieldDecl semi)* "}" } } |
  ArrayType { "[" expr "]" type } |
  SliceType { "[" "..."? "]" type } |
  MapType { kw<"map"> "[" type "]" type } |
  typeName |
  ParameterizedType
}

FieldDecl {
  (FieldName ("," FieldName)* type | "*"? (typeName | ParameterizedType)) String?
}

signature { Parameters ~paren (Parameters | type)? }

Parameters { "(" commaSep<Parameter> ~paren ")" }

Parameter { idList? "..."? type }

MethodElem { FieldName signature }
typeOrUnderlying { type | UnderlyingType { "~" type } }
typeElem {
  typeOrUnderlying |
  TypeElem { typeOrUnderlying ("|" typeOrUnderlying)+ }
}

Block { "{" semiSep<statement> "}" }

ConstSpec { idList (type? "=" exprList)? }
ConstDecl { kw<"const"> (ConstSpec | "(" (ConstSpec semi)* ")") }

TypeSpec { typeName "=" type | typeName TypeParams? type }
TypeDecl { kw<"type"> (TypeSpec | ("(" TypeSpec semi)* ")") }

VarSpec { idList (type ("=" exprList) | "=" exprList) }
VarDecl { kw<"var"> (VarSpec | "(" (VarSpec semi)* ")") }
shortVarDecl[@name=VarDecl] { idList ~shortvar ":=" exprList }

FunctionDecl { kw<"func"> VariableName TypeParams? signature Block? }

MethodDecl { kw<"func"> Parameters FieldName signature Block? }

ImportSpec { ("." | PackageName) String }
ImportDecl { kw<"import"> (ImportSpec | "(" (ImportSpec semi)* ")") }

declaration {
  ConstDecl | TypeDecl | VarDecl
}

expr[@isGroup=Expr] {
  operand |
  Conversion[@dynamicPrecedence=-1] { type !convert ~paren "(" expr ","? ")" } |
  MethodExpr { type !dot "." FieldName } |
  SelectorExpr { expr !dot "." FieldName } |
  IndexExpr { expr !index ~bracket "[" expr ","? "]" } |
  SliceExpr { expr !slice ~bracket "[" expr? ":" expr? (":" expr)? "]" } |
  TypeAssertion { expr !type "." "(" type ")" } |
  CallExpr { expr !call Arguments } |
  UnaryExp { (ArithOp<"+" | "-"> | LogicOp<"!"> | BitOp<"^"> | DerefOp<"*" | "&"> | "<-") !unary expr } |
  BinaryExp {
    expr !mult (ArithOp<"*" | "/" | "%"> | BitOp<"<<" | ">>" | "&" | "&^">) expr |
    expr !add (ArithOp<"+" | "-"> | BitOp<"|" | "^">) expr |
    expr !compare CompareOp expr |
    expr !and LogicOp<"&&"> expr |
    expr !or LogicOp<"||"> expr
  }
}

Arguments {
  "(" ((exprList | type ("," exprList)?) ("..." ","?)?)? ")"
}

operand {
  Number |
  String |
  Rune |
  QualifiedName |
  VariableName |
  Parameterized { (VariableName | QualifiedName) ~bracket TypeArgs } |
  TypedLiteral { literalType LiteralValue } |
  ParenthesizedExpr { "(" expr ")" } |
  FunctionLiteral { kw<"func"> signature Block }
}

LiteralValue { "{" commaSep<Element { (Key { expr | LiteralValue } ":")? (expr | LiteralValue) }> "}" }

exprList { expr ~ids ("," expr? ~ids)* }
idList { VariableName ~ids ("," VariableName ~ids)* }

statement[@isGroup=Statement] {
  simpleStatement |
  declaration |
  Block |
  LabeledStatement { LabelName ":" statement } |
  IfStatement |
  SwitchStatement {
    kw<"switch"> (simpleStatement semi)? expr SwitchBlock
  } |
  TypeSwitchStatement {
    kw<"switch"> (simpleStatement semi)? (VariableName ~shortvar ":=")? expr "." "(" kw<"type"> ")" typeSwitchBlock
  } |
  ForStatement {
    kw<"for"> (expr | ForClause | RangeClause) Block
  } |
  GoStatement {
    kw<"go"> expr
  } |
  SelectStatement {
    kw<"select"> SelectBlock { "{" (Case<SendStatement | ReceiveStatement> semiSep<statement>)* "}" }
  } |
  ReturnStatement {
    kw<"return"> exprList?
  } |
  GotoStatement {
    (kw<"break"> | kw<"continue">) LabelName? |
    kw<"goto"> LabelName
  } |
  FallthroughStatement {
    kw<"fallthrough">
  } |
  DeferStatement {
    kw<"defer"> expr
  }  
}

IfStatement { kw<"if"> (simpleStatement semi)? expr Block (!else kw<"else"> (IfStatement | Block)) }

Case<expr> { (kw<"case"> expr | kw<"default">) ":" }

SwitchBlock {
  "{" (Case<exprList> semiSep<statement>)* "}"
}

ForClause { simpleStatement semi expr semi simpleStatement }

RangeClause { (exprList "=" | idList ":=") kw<"range"> expr }

typeSwitchBlock[@name=SwitchBlock] {
  "{" (Case<commaSep1<type>> semiSep<statement>)* "}"
}

ReceiveStatement { (exprList "=" | idList ":=") expr }

PackageClause { kw<"package"> PackageName }

simpleStatement {
  ExprStatement { expr } |
  SendStatement |
  IncDecStatement { expr IncDecOp } |
  Assignment { exprList ("=" | UpdateOp) exprList } |
  shortVarDecl
}

SendStatement { expr !send "<-" expr }

kw<term> { @specialize[@name={term}]<identifier, term> }

commaSep<expr> { (expr ("," expr)*)? ","? }

commaSep1<expr> { expr ("," expr)* ","? }

semiSep<expr> { (expr semi | ";")* }

LogicOp<expr> { expr }
ArithOp<expr> { expr }
BitOp<expr> { expr }
DerefOp<expr> { expr }

semi { ";" | insertedSemi }

@local tokens {
  blockCommentEnd { "*/" }
  blockCommentNewline { "\n" }
  @else blockCommentContent
}

@skip {} {
  BlockComment[isolate] { "/*" (blockCommentContent | blockCommentNewline)* blockCommentEnd }
}

@external tokens semicolon from "./tokens" { insertedSemi }

@context trackTokens from "./tokens"

@tokens {
  space[@export] { $[ \t\n\r]+ }
  LineComment { "//" ![\n]* }

  @precedence { LineComment "/" }

  digit { $[0-9] }
  digits { ("_"? digit)+ }
  hexDigits { ("_"? (digit | $[a-fA-F]))+ }

  decimalNumber { ("." digits | digits ("." digits?)?) ($[eE] $[+-]? digits)? }
  hexNumber { "0" $[xX] ("." hexDigits | hexDigits ("." hexDigits?)?) ($[pP] $[+-]? digits)? }
  octNumber { "0" $[oO] ("_"? $[0-7])+ }
  binNumber { "0" $[bB] ("_"? $[01])+ }
  Number { (decimalNumber | hexNumber | octNumber | binNumber) "i"? }

  Rune[isolate] { "'" ("\\" _ | ![\\'\n])* "'"? }

  String[isolate] { '"' ("\\" _ | ![\\"\n])* '"'? | '`' ![`]* '`' }

  letter { $[_a-zA-Z\u{a1}-\u{10ffff}] }

  identifier[@export] { letter (letter | digit)* }

  @precedence { Number, identifier }

  UpdateOp { ($[-+|^*/%&] | "<<" | ">>" | "&^") "=" }
  CompareOp { "==" | "!=" | "<" | "<=" | ">" | ">=" }
  IncDecOp { "++" | "--" }

  "<-" "=" ":=" ";" "..." "."
  "(" ")"[@export=closeParen]
  "{" "}"[@export=closeBrace]
  "[" "]"[@export=closeBracket]
}

@external propSource goHighlighting from "./highlight"

@detectDelim
